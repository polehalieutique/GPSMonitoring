---
title: "Vignette1"
author: "Jerome Guitton"
date: "14/10/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
getwd()
rm (list=ls())
library(sf)
library(adehabitatLT)
library(sqldf)
library(dplyr)
library(ggplot2)
library(ggpubr)
library(ggpubr)
library(RPostgreSQL)
library(tidyr)
library(units)
library(GPSMonitoring)

```

## loading Gpx files

A set of files are provided within the data/GPX directory.

```{r}

liste_fichiers<-paste('../R/',dir('../R/'),sep='')

for (i in 1:length(liste_fichiers))
{
  source(liste_fichiers[i])
}
load('../data/DEMERSTEM_gps.Rdata')

```


```{r }

gps.all_init<-GPX.load(gpx_rep='../data/gpx') 

head(gps.all_init)
head(GPSdataset)
GPSdataset<-GPSdataset %>% filter(date_heure<"2019-09-30 20:20:53 CEST")


#Pour faire en sorte que les 2 types de données se ressemblent, if faut que le champ date_heyre soir data, que longitude, latitude deviennent la partie geo du sf
#Qu'il t ait track_fid par code_village_code_engin_code_pecheur

#----------------------Test ç virer
# GPSdataset %>% dplyr::distinct(code_village,code_engin,code_pecheur) %>% 
# mutate(track_fid=row_number(),track_seg_id=track_fid,filename=paste(code_village,code_engin,code_pecheur,'.gpx',sep='_')) %>% 
# inner_join(GPSdataset) %>% arrange(track_fid,date_heure) %>% rename(date=time) %>%
#   mutate(track_seg_point_id=row_number())
#   st_as_sf(coords = c("longitude", "latitude"), crs = 4326)->gps.all
# 
# GPSdataset %>% dplyr::distinct(code_village,code_engin,code_pecheur) %>% 
# mutate(track_fid=row_number(),track_seg_id=track_fid,filename=paste(code_village,code_engin,code_pecheur,'.gpx',sep='_')) %>% 
# inner_join(GPSdataset) %>% 
# mutate(track_fid=row_number(),track_seg_id=track_fid,filename=paste(code_village,code_engin,code_pecheur,'.gpx',sep='_'))  %>% 
#   group_by(track_fid) %>% mutate(rank = row_number(-track_fid)) %>% arrange(name, rank)  
#   

#GPSdataset %>% st_drop_geometry() %>% group_by(track_seg_point_id) %>% dplyr::summarise(nb=n())
library(tidyr)

GPSdataset %>% mutate(filename=paste(code_village,code_engin,code_pecheur,'.gpx',sep='_')) %>% 
arrange (filename) %>% dplyr::distinct(code_village,code_engin,code_pecheur,filename) %>% 
dplyr::mutate(track_fid=row_number(),track_seg_id=track_fid) %>% 
inner_join(GPSdataset) %>%  
group_by(filename) %>% arrange (filename,date_heure) %>% dplyr::mutate(track_seg_point_id = row_number()) %>% 
  dplyr::rename(time=date_heure) %>%
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326,remove=FALSE)->gps.all

head(gps.all)
ggplot(gps.all)+geom_sf(aes(color=filename),size=0.2)+geom_sf(data=fond)
fond
unique(gps.all$code_village)
#gps.all<-GPX.load(file='../data/gpx/KPN_FMCl_0003_GA_2020-10-17.gpx') 


#ggplot(gps.all)+geom_sf(aes(color=filename))



```
## Data curation

### Extent of area of interest

```{r}

#pol.extent is the extent of the case study. I want to keep all data include in that extent 

emprise<-matrix(c(-17,11,-14,11,-14,9,-15,9,-17,11),ncol=2, byrow=TRUE)
pol.extent <-st_as_sf(st_sfc(st_polygon(list(emprise))))
st_crs(pol.extent) = 4326

GPS.data<-gps.all
#exclude is some area to exclude from analysis as position too close from the port
# I want to exlude all data that intersect exclude area 
ports<-data.frame(code=c('KAY'),long=c(-14.61),lat=c(10.62))
ports.sf<- st_as_sf(ports,coords=c("long","lat"),crs=4326)
exclude<-st_as_sf(st_union(st_buffer(ports.sf,1000)))

ggplot(exclude)+geom_sf(fill='red')

gps.all.cur<-GPS.curation(gps.all,extent=pol.extent,exclude=exclude)



g1<-ggplot(gps.all)+geom_sf()+geom_sf(data=exclude,fill=rgb(0.8,0.11,0.1,0.5))+
  geom_sf(data=pol.extent,fill=rgb(0.1,0.8,0.1,0.5))

g2<-ggplot(gps.all.cur)+geom_sf()+geom_sf(data=exclude,fill=rgb(0.8,0.11,0.1,0.5))+
  geom_sf(data=pol.extent,fill=rgb(0.1,0.8,0.1,0.5))

ggarrange(g1,g2)


```

### Cut trajectory in piece of traject composed of following position 

We considered that if there is more than n (minutes) between 2 position, we are starting a new traject. 

The id of a GPS record is the filemename

```{r}
limit<-600*120 #2 hours between two point and we consider a new traject
 #limit<-240
head(gps.all.cur)

GPS.data<-gps.all.cur
gps.all.cur_traj<-GPS.add_traj_number(gps.all.cur,limit)  

gps.all.cur_traj %>% mutate(x = sf::st_coordinates(.)[,1],
                y = sf::st_coordinates(.)[,2])->gps.all.cur_traj


unique(gps.all.cur_traj$track_fid)
unique(gps.all.cur_traj[gps.all.cur_traj$track_fid==2,]$no_trajet)

#ggplot(gps.all.cur_traj)+geom_sf(aes(color=as.factor(paste(track_fid,no_trajet))))

ggplot(filter(gps.all.cur_traj,duree<350))+geom_histogram(aes(x=duree))

ggplot(filter(gps.all.cur_traj,duree<310 ))+geom_histogram(aes(x=duree))

head(gps.all.cur_traj)
#On est pas mal mais il faudrait mettre la dernière duree de chaque trajet à 0

```



### Standardize duration between 2 position


```{r }


gpstmp<-filter(gps.all.cur_traj,track_fid==1)

#gps.all.cur_traj %>% st_drop_geometry() %>% dplyr::group_by(track_fid) %>% dplyr::summarise(nb=n())
head(gps.all.cur_traj)

step_dt=300
R.gps.all.cur_traj<-Redis.traj(GPS.data=st_drop_geometry(gps.all.cur_traj),step=step_dt)


projcrs <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
R.gps.all.cur_traj <- st_as_sf(x = R.gps.all.cur_traj,
               coords = c("x", "y"),
               crs = projcrs)



ggplot(R.gps.all.cur_traj)+geom_sf(aes(color=no_trajet))+ggtitle(paste("Tracks redistribute in a ",step_dt," period"))

```
## Join Observation data


```{r}
Observed_FO<-read.csv('../data/Observed_FO.csv')


R.gps.all.cur_traj %>% tidyr::separate(filename,c('code_village','code_engin','code_pecheur'),remove=FALSE,sep='_') %>% 
  mutate(code_pecheur=as.numeric(code_pecheur)) %>%  mutate(longitude = sf::st_coordinates(.)[,1],
                                             latitude = sf::st_coordinates(.)[,2])->R2
#add id number for each position of a traject
R2$id<-(R2 %>% group_by(no_trajet) %>% mutate(id=row_number()) %>% select (id))$id

R2$date<-as.POSIXct(R2$date)
R2 %>% mutate(obs=as.integer(1),activity='UK')->R2
head(R2)
for (compteur in seq(1,length(Observed_FO$X)))
{  
#compteur<-1  
R2<-R2 %>% mutate(activity=case_when(
code_village==Observed_FO[compteur,]$code_village & code_engin==Observed_FO[compteur,]$code_engin  & code_pecheur==Observed_FO[compteur,]$code_pecheur & date>Observed_FO[compteur,]$start_op & date<Observed_FO[compteur,]$end_op ~ 'active',
TRUE ~ activity),obs=case_when(
code_village==Observed_FO[compteur,]$code_village & code_engin==Observed_FO[compteur,]$code_engin  & code_pecheur==Observed_FO[compteur,]$code_pecheur & date>Observed_FO[compteur,]$start_op & date<Observed_FO[compteur,]$end_op ~ Observed_FO[compteur,]$X,
TRUE ~ obs))
}
compteur<-40
liste_trajet_avec_obs<-R2 %>% st_drop_geometry()%>% filter(activity=='active')%>% dplyr::distinct(no_trajet)                           



filter(R2,no_trajet==1 & activity=='active') %>% distinct ()
ggplot(filter(R2,no_trajet %in% liste_trajet_avec_obs$no_trajet))+geom_sf(aes(color=as.factor(activity)),lwd=0.1)+ggtitle("Tracks redistribute in a 60s period with observation")


```


# After having GPS + Observed data, try to predict on non observed data

## First an overview of observed data

```{r}
head(R2)

#Remettre avec un shapefile dans data
#Chargement du fond de carte
load("../data/fond.Rdata")

liste_trajet_avec_obs<-R2 %>% st_drop_geometry()%>% filter(activity=='active')%>% dplyr::distinct(no_trajet)     

R2_avec_obs<-R2 %>%  filter(no_trajet %in% liste_trajet_avec_obs$no_trajet) 


R2_avec_obs %>% st_drop_geometry() %>% 
  group_by(code_engin,activity,dist) %>% dplyr::summarise(frequence=n()) %>%  ggplot()+
  geom_smooth(aes(x=dist,y=frequence,col=activity))+
  facet_wrap(~code_engin,scales = "free")+ggtitle('Distribution vitesse en fonction observation a bord')

bb<-st_bbox(R2_avec_obs)

ggplot(R2_avec_obs)+geom_sf(data=fond)+geom_sf(aes(color=activity),alpha=0.45,lwd=1)+
    scale_fill_viridis_c(option = "plasma", trans = "sqrt")+xlim(as.numeric(bb$xmin),as.numeric(bb$xmax))+ ylim(as.numeric(bb$ymin), as.numeric(bb$ymax))+facet_wrap(~code_engin)


engin_encours<-'FMCl'

head(R2_avec_obs)
R2_avec_obs %>% filter(code_engin==engin_encours) %>% ggplot()+geom_line(aes(x=date,y=dist))+
  geom_point(aes(x=date,dist,col = activity))  +
  facet_wrap(~no_trajet,scale='free')+ggtitle("Relation observation et vitesse")


R2_avec_obs %>% filter(code_engin==engin_encours) %>% ggplot()+geom_line(aes(x=date,y=R2n))+
  geom_point(aes(x=date,R2n,col = activity))  +
  facet_wrap(~no_trajet,scale='free')+ggtitle("Relation observation et R2n")

R2_avec_obs %>% filter(code_engin==engin_encours) %>% ggplot()+geom_line(aes(x=date,y=rel.angle))+
  geom_point(aes(x=date,rel.angle,col = activity))  +
  facet_wrap(~no_trajet,scale='free')+ggtitle("Relation observation et rel.angle")


```
## And then, modelize the relationship between fishing event and speed or other trajectory parameters

```{r}

observation<-'activity'



#On teste avec les 3 paramètres 
gear.glm<-model.traj.glm(filter(R2,code_engin==engin_encours),observation='activity')

summary(gear.glm)

#Je restreint aux paramètres 
gear.glm<-model.traj.glm(filter(R2,code_engin==engin_encours),observation='activity',form= "dist+rel.angle")

gear.glm2<-model.traj.glm(filter(R2,code_engin==engin_encours),observation="activity",form= "dist+R2n+rel.angle")

summary(gear.glm)
plot(gear.glm)


summary(gear.glm2)
plot(gear.glm2)


```

## Model used to predict missing observation

```{r}



R2.pred<-glm.predict(filter(R2,code_engin==engin_encours),gear.glm2,seuil=0.5)


p1<-ggplot(R2.pred)+geom_sf(aes(color=as.factor(predict.glm)),alpha=0.45,lwd=1)+
    scale_fill_viridis_c(option = "plasma", trans = "sqrt")
p2<-ggplot(filter(R2,code_engin==engin_encours))+geom_sf(aes(color=activity),alpha=0.45,lwd=1)+
    scale_fill_viridis_c(option = "plasma", trans = "sqrt")
ggarrange(p1,p2,ncol=1)





```
Obvisouly the Observed Fishing activities does not seem to be really efficient to produce a tight prediction

## How to improve observed values


### We can review observed fishing activities using visual interface: we define a new observation column : activity_plus

Pour recharger à partir de là
```{r}
load("~/PESCAOS/Rpackages/intermediaire.Rdata.RData")

R.gps.all.cur_traj %>% tidyr::separate(filename,c('code_village','code_engin','code_pecheur'),remove=FALSE,sep='_') %>% 
  mutate(code_pecheur=as.numeric(code_pecheur)) %>%  mutate(longitude = sf::st_coordinates(.)[,1],
                                             latitude = sf::st_coordinates(.)[,2])->R2

```

```{r}



#First i can identifiy trajectory that seems to be observable for the given gear

R2 %>% filter(code_engin==engin_encours & no_trajet==18) %>% 
  ggplot()+geom_sf(aes(color=as.factor(no_trajet)))+facet_wrap(~no_trajet)

#I create the new column and set values to Unknown, 
R2$activity_plus<-'UK'
head(R2)
#I will review a selction of trajectories
liste_trajet_silico<-c(1,18,20)
library(shiny)
Rtmp<-silicoTraj(filter(R2,no_trajet==i),mode='speed')
for (i in liste_trajet_silico)
{
  R2<-track_replace(R2,silicoTraj(filter(R2,no_trajet==i),mode='speed'))
}


for (i in liste_trajet_silico)
{
  R2<-track_replace(R2,silicoTraj(filter(R2,no_trajet==i),mode='map'))
}

```

With these new set of data i try to improve the model 

```{r}
traj<-filter(R2,code_engin==engin_encours)
observation<-'activity_plus'
traj %>% filter(!!as.name(observation)=='active') %>% dplyr::distinct(no_trajet)


gear.glm.plus<-model.traj.glm(filter(R2,code_engin==engin_encours),observation="activity_plus",form= "dist+R2n+rel.angle")

summary(gear.glm.plus)
plot(gear.glm.plus)

R2.pred.plus<-glm.predict(filter(R2,code_engin==engin_encours),gear.glm.plus,seuil=0.5)


p1<-ggplot(R2.pred.plus)+geom_sf(aes(color=as.factor(predict.glm)),alpha=0.45,lwd=1)+
    scale_fill_viridis_c(option = "plasma", trans = "sqrt")
p2<-ggplot(filter(R2.pred.plus,code_engin==engin_encours))+geom_sf(aes(color=activity_plus),alpha=0.45,lwd=1)+
    scale_fill_viridis_c(option = "plasma", trans = "sqrt")
ggarrange(p1,p2,ncol=1)


ggplot(R2.pred.plus)+geom_point(aes(x=id,y=(predict.glm)))+
  facet_wrap(~no_trajet,scales='free')

```



### I can add additional co variable 
```{r}

R2test_retour<-all.add.nb.point(R2.pred.plus,r=2000,temp_windows=20)



ggplot(filter(R2test_retour,no_trajet==20))+geom_sf(aes(color=circle2000))

ggplot(filter(R2test_retour,no_trajet==20))+geom_point(aes(x=id,y=circle2000,color=activity_plus))


```



```{r}

gear.glm.plus.nb<-model.traj.glm(filter(R2test_retour,code_engin==engin_encours),observation="activity_plus",form= "dist+R2n+rel.angle+circle2000")

summary(gear.glm.plus)

summary(gear.glm.plus.nb)
plot(gear.glm.plus.nb)

R2.pred.plus.nb<-glm.predict(filter(R2test_retour,code_engin==engin_encours),gear.glm.plus.nb,seuil=0.5) %>% filter(!is.na(predict.glm))


p1<-ggplot(R2.pred.plus.nb)+geom_sf(aes(color=as.factor(predict.glm)),alpha=0.45,lwd=1)+
    scale_fill_viridis_c(option = "plasma", trans = "sqrt")
p2<-ggplot(filter(R2.pred.plus.nb,code_engin==engin_encours))+geom_sf(aes(color=activity_plus),alpha=0.45,lwd=1)+
    scale_fill_viridis_c(option = "plasma", trans = "sqrt")
ggarrange(p1,p2,ncol=1)


```

## Random Forest prediction

Random forest is another algorythm which is able to predict fishing activity using observed values. Methodology is describe in folowing article :

[Estimating fishing effort in small-scale fisheries using GPS tracking data and random forests] (https://dx.doi.org/10.1016/j.ecolind.2020.107321)

```{r}
list_used_packages <- c("ranger", "randomForest","caret")
## Be careful to laod dplyr after ggmap or use dplyr::summarize instead of summaryze
invisible(lapply(list_used_packages , require, character.only = TRUE))

#To select some 
colX    <- which(stringr::str_detect(colnames(labelled_dta) , 'dist|circle|angle'))
form <- paste(colnames(labelled_dta)[colX],  collapse = ' + ') 
form <-"dist + abs.angle + rel.angle + circle2000"
mod.RF<-model.traj.RF(traj=R2.pred.plus.nb %>% filter(substr(code_engin,1,3)==gear),observation='activity_plus',form=form)

R2.pred.plus.nb.RF<-RF.predict(traj=R2.pred.plus.nb %>% filter(substr(code_engin,1,3)==gear),mod.RF)
  
ggplot(R2.pred.plus.nb.RF)+geom_sf(aes(color=predict.RF),lwd=0.1)+geom_sf(data=st_crop(fond,st_bbox(R2.pred.plus.nb.RF)))+
  scale_color_manual(values = c("active" = "lightgreen","UK"="orange")) +
  ggtitle("Map of predict activities using RF method")

ggplot(R2.pred.plus.nb.RF)+geom_sf(aes(color=predict.glm),lwd=0.1)+geom_sf(data=st_crop(fond,st_bbox(R2.pred.plus.nb.RF)))+
  scale_color_manual(values = c("active" = "lightgreen","UK"="orange")) +
  ggtitle("Map of predict activities using GLM method")



```




```{r}
library(leaflet)
library(simplevis)
CE = sf::as_Spatial(filter(R2,no_trajet==no_trajet_encours) )


no_trajet_encours<-29
head(R2)
filter(R2,no_trajet==no_trajet_encours) %>% st_coordinates() %>% st_linestring() ->ligne

filter(R2,no_trajet==no_trajet_encours) %>% ggplot()+geom_sf(aes(color=activity))

pal <- colorFactor(
  palette = 'Dark2',
  domain = R2$activity_plus
)

head(R2_avec_obs) 


  leaflet() %>% addProviderTiles("CartoDB.Positron") %>% leaflet::addPolygons(data = ligne, 
                       color = "#ff0000", 
                       weight = 1, 
                       fillOpacity = 0, 
                       opacity = 1) %>% 
    leaflet::addCircles(data = R2,color = ~pal(activity),fill = ~pal(activity),popup = ~as.character(paste("idpos:",id,"no_trajet:",no_trajet," Activ ",activity," ",date)), opacity = 1) 


#Un leafleft dès qu'il y a trop de point, c'est compliqué (pas rapide)     
#  %>% 
#    addLabelOnlyMarkers(data=R2_avec_obs_id,
#                            label=~as.character(id), 
#                            labelOptions = labelOptions(noHide = T, direction = 'center', textOnly = T,textsize="13px")) 

observation_plus<-data.frame(no_trajet=no_trajet_encours,activity='active',debut=93,fin=174)
observation_plus<-rbind(observation_plus,c(no_trajet_encours,'active',401,517))
observation_plus<-rbind(observation_plus,c(no_trajet_encours,'active',649,891))
observation_plus<-rbind(observation_plus,c(no_trajet_encours,'active',926,1179))
observation_plus<-rbind(observation_plus,c(no_trajet_encours,'active',1504,1554))


R2_avec_obs_id_nosf<-R2_avec_obs_id %>% st_drop_geometry()

g1<-R2_avec_obs_id %>% ggplot()+geom_sf(aes(color=activity),lwd=0.5)+ggtitle("Données initiale")

R2_avec_obs_id_nosf_plus<-sqldf("select id,case when debut is null then A.activity else B.activity end as activity_plus   from R2_avec_obs_id_nosf A left join observation_plus B on (A.id between B.debut and B.fin)",drv='SQLite')
  
R2_avec_obs_id_plus<-R2_avec_obs_id %>% inner_join(R2_avec_obs_id_nosf_plus,by='id')

R2_avec_obs_id_plus %>% ggplot()+geom_sf(aes(color=activity_plus))+ggtitle("Données avec observation supp")


  leaflet() %>% addProviderTiles("CartoDB.Positron") %>% leaflet::addPolygons(data = ligne, 
                       color = "#ff0000", 
                       weight = 1, 
                       fillOpacity = 0, 
                       opacity = 1) %>% 
    leaflet::addCircles(data = R2_avec_obs_id_plus,color = ~pal(activity_plus),fill = ~pal(activity_plus),popup = ~as.character(paste("idpos:",id,"no_trajet:",no_trajet," Activ ",activity_plus," ",date)), opacity = 1) 


```

## Overview of predict data

```{r}

R2.pred.plus.nb %>% st_drop_geometry() %>% 
  group_by(code_engin,predict.glm,dist) %>% dplyr::summarise(frequence=n()) %>%  ggplot()+
  geom_smooth(aes(x=dist,y=frequence,col=predict.glm))+
  facet_wrap(~code_engin,scales = "free")+ggtitle('Distribution vitesse en fonction observation a bord')

bb<-st_bbox(R2.pred.plus.nb)

ggplot(R2.pred.plus.nb)+geom_sf(data=fond)+geom_sf(aes(color=predict.glm),alpha=0.45,lwd=1)+
    scale_fill_viridis_c(option = "plasma", trans = "sqrt")+xlim(as.numeric(bb$xmin),as.numeric(bb$xmax))+ ylim(as.numeric(bb$ymin), as.numeric(bb$ymax))+facet_wrap(~code_engin)




head(R2.pred.plus.nb)
R2.pred.plus.nb %>% filter(code_engin==engin_encours) %>% ggplot()+geom_line(aes(x=date,y=dist))+
  geom_point(aes(x=date,dist,size=id,col = predict.glm))  +
  facet_wrap(~no_trajet,scale='free')+ggtitle("Relation observation et vitesse")->test

ggplotly(test)


R2.pred.plus.nb %>% filter(code_engin==engin_encours) %>% ggplot()+geom_line(aes(x=date,y=R2n))+
  geom_point(aes(x=date,R2n,col = predict.glm))  +
  facet_wrap(~no_trajet,scale='free')+ggtitle("Relation observation et R2n")

R2.pred.plus.nb %>% filter(code_engin==engin_encours) %>% ggplot()+geom_line(aes(x=date,y=rel.angle))+
  geom_point(aes(x=date,rel.angle,col = predict.glm))  +
  facet_wrap(~no_trajet,scale='free')+ggtitle("Relation observation et rel.angle")


```




## Applied model on all non observed trajectory

```{r}
R2_engin<-filter(R2,code_engin==engin_encours) %>% mutate(observation2=as.numeric(activity=='active'))

ggplot(R2_engin)+geom_sf(aes(color=dist))
seuil<-0.35
R2_engin$predict_glm<-(predict(model[[2]],R2_engin,type="response"))>seuil


ggplot(R2_engin)+geom_sf(aes(color=predict_glm))


R2_engin<-R2_engin %>% mutate(long=sf::st_coordinates(.)[,1],lat=sf::st_coordinates(.)[,2])
head(R2_engin)

ggplot(filter(R2_engin,predict_glm==TRUE), aes(x=long, y=lat) ) +
  geom_bin2d(bins = 10) +
  scale_fill_continuous(type = "viridis") +
  theme_bw()

bb<-st_bbox(filter(R2_engin,predict_glm==TRUE))


ggplot(fond)+geom_sf(fill=NA)+
  geom_density_2d_filled(data=filter(R2_engin,predict_glm==TRUE),aes(x = long, y = lat),breaks = seq(0.05, 120.0, length.out = 25))+
  xlim(as.numeric(bb$xmin),as.numeric(bb$xmax))+ ylim(as.numeric(bb$ymin),as.numeric(bb$ymax))

  

```


## For all gear using model (dist+R2n based on improved observed activity)

```{r}

engin_encours<-'FMCl'
engin_encours<-'YO'
engin_encours<-'FMCy'

R2_engin<-filter(R2,code_engin==engin_encours) %>% mutate(observation2=as.numeric(activity=='active'))

dist.limit<-c(0.0010,0.0020)
dist<-0.0006
R2_engin<-R2%>% mutate(predict_glm=(dist>dist.limit[1] & dist<dist.limit[2]))


ggplot(R2_engin)+geom_sf(aes(color=predict_glm))+facet_wrap(~code_engin)

bb<-st_bbox(filter(R2_engin,predict_glm==TRUE))



ggplot(filter(R2_engin,code_engin=='YO'))+geom_sf(aes(color=predict_glm))+
  xlim(as.numeric(bb$xmin),as.numeric(bb$xmax))+ ylim(as.numeric(bb$ymin),as.numeric(bb$ymax))+
  geom_sf(data=fond)+facet_wrap(~code_engin)


R2_engin<-R2_engin %>% mutate(long=sf::st_coordinates(.)[,1],lat=sf::st_coordinates(.)[,2])
head(R2_engin)

ggplot(filter(R2_engin, predict_glm==TRUE), aes(x=longitude, y=latitude) ) +
  geom_bin2d(bins = 10) +
  scale_fill_continuous(type = "viridis") +
  theme_bw()

bb<-st_bbox(filter(R2_engin,predict_glm==TRUE))


ggplot(fond)+geom_sf(fill=NA)+
  geom_density_2d_filled(data=filter(R2_engin,predict_glm==TRUE),aes(x = long, y = lat),breaks = seq(0.01, 120.0, length.out = 20))+
  xlim(as.numeric(bb$xmin),as.numeric(bb$xmax))+ ylim(as.numeric(bb$ymin),as.numeric(bb$ymax))+facet_wrap(~code_engin)







```




## Regular grid end fishing event

```{r}

engin_encours<-'FMCl'
engin_encours<-'YO'
engin_encours<-'FMCy'

#Remettre avec un shapefile dans data
#fond<-st_read(con,query="select st_intersection(st_buffer(geom,0),ST_GeomFromText('POLYGON((-18 13,-13 13,-13 7.94,-18 7.94,-18 13))',4326)) as geom 
#					   from communes_uni")
load("../data/grid.Rdata")
ggplot(grid)+geom_sf(color=NA)+geom_sf(data=R2_engin)




library(sf)
 st_join(grid,filter(R2.pred.plus,predict_glm==TRUE),left=FALSE) %>% group_by(code_engin,id) %>% dplyr::summarize(total=n()) %>% 
   ggplot()+ geom_sf(aes(fill=total),lwd=0)+geom_sf(data=fond)+facet_wrap(~code_engin)+ scale_fill_continuous(trans = 'reverse')+
  xlim(as.numeric(bb$xmin),as.numeric(bb$xmax))+ ylim(as.numeric(bb$ymin),as.numeric(bb$ymax))










```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
